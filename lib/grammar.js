/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./grammar.macro.js#3544aa7962d3ff77beb545ac72e57c55569f019c
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
import { interpolateArray as _interpolateArray, interpolateFragmentChildren as _interpolateFragmentChildren, interpolateString as _interpolateString } from "@bablr/agast-helpers/template";
import * as _l from "@bablr/agast-vm-helpers/languages";
import * as _t from "@bablr/agast-helpers/shorthand";
let _initProto, _DoctypeTagDecs, _ReferenceTagDecs, _GapTagDecs, _ShiftTagDecs, _NullTagDecs, _ArrayTagDecs, _NodeDecs, _PropertyDecs, _OpenNodeTagDecs, _OpenFragmentTagDecs, _CloseNodeTagDecs, _CloseFragmentTagDecs, _BooleanAttributeDecs, _MappingAttributeDecs, _IdentifierPathDecs, _StringDecs, _LiteralTagDecs, _NumberDecs, _IntegerDecs, _BooleanDecs, _InfinityDecs, _PunctuatorDecs, _KeywordDecs, _AnyDecs;
import { Node, CoveredBy, InjectFrom, Attributes, UnboundAttributes, AllowEmpty } from '@bablr/helpers/decorators';
import { notNull } from '@bablr/agast-helpers/tree';
import { buildBoolean, buildNullTag, buildString } from '@bablr/agast-vm-helpers';
import * as productions from '@bablr/helpers/productions';
import * as Space from '@bablr/language-en-blank-space';
export const canonicalURL = 'https://bablr.org/languages/core/en/cstml';
export const dependencies = {
  Space
};
const escapables = new Map(Object.entries({
  n: '\n',
  r: '\r',
  t: '\t',
  0: '\0'
}));
export const getCooked = (escapeNode, span, ctx) => {
  let cooked;
  const codeNode = escapeNode.get('code');
  const type = ctx.sourceTextFor(codeNode.get('typeToken'));
  const value = ctx.sourceTextFor(codeNode.get('value'));
  if (!span.startsWith('String')) {
    throw new Error('not implemented');
  }
  if (!type) {
    const match_ = ctx.sourceTextFor(codeNode);
    cooked = escapables.get(match_) || match_;
  } else if (type === 'u') {
    cooked = parseInt(value, 16);
  } else {
    throw new Error();
  }
  return cooked.toString(10);
};
export function* eatMatchTrivia() {
  if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
    verb: _t.s_node(_l.Instruction, "Identifier", "match"),
    arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
      openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
      values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
        alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
          elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Regex, "Punctuator", "["),
            elements: [_t.node(_l.Regex, "Character", [_t.lit(" ")], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\t")], {}, {
              cooked: "\t"
            }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\r")], {}, {
              cooked: "\r"
            }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\n")], {}, {
              cooked: "\n"
            }))], {}, {})],
            closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
          }, {
            negate: false
          })]
        }, {})],
        closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
      }, {})],
      closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
    }, {})
  }, {})) {
    return yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`language`, _t.ref`namespaceSeparatorToken`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`triviaToken`, _t.ref`tokenToken`], {
              triviaToken: _t.s_node(_l.CSTML, "Punctuator", "#"),
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            language: _t.node(_l.CSTML, "IdentifierPath", [_t.ref`segments[]`, _t.arr(), _t.ref`segments[]`], {
              segments: [_t.s_node(_l.CSTML, "Identifier", "Space")]
            }, {}),
            namespaceSeparatorToken: _t.s_node(_l.CSTML, "Punctuator", ":"),
            type: _t.s_node(_l.CSTML, "Identifier", "Space"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  return null;
}
export const grammar = class CSTMLGrammar {
  static {
    [_initProto] = _applyDecs(this, [[Node, 2, "Document"], [_DoctypeTagDecs, 2, "DoctypeTag"], [_ReferenceTagDecs, 2, "ReferenceTag"], [_GapTagDecs, 2, "GapTag"], [_ShiftTagDecs, 2, "ShiftTag"], [_NullTagDecs, 2, "NullTag"], [_ArrayTagDecs, 2, "ArrayTag"], [_NodeDecs, 2, "Node"], [Node, 2, "Fragment"], [_PropertyDecs, 2, "Property"], [[Node, AllowEmpty], 2, "Flags"], [_OpenNodeTagDecs, 2, "OpenNodeTag"], [_OpenFragmentTagDecs, 2, "OpenFragmentTag"], [AllowEmpty, 2, "Attributes"], [_CloseNodeTagDecs, 2, "CloseNodeTag"], [_CloseFragmentTagDecs, 2, "CloseFragmentTag"], [_BooleanAttributeDecs, 2, "BooleanAttribute"], [_MappingAttributeDecs, 2, "MappingAttribute"], [AllowEmpty, 2, "TagType"], [_IdentifierPathDecs, 2, "IdentifierPath"], [_StringDecs, 2, "String"], [[AllowEmpty, Node], 2, "StringContent"], [Node, 2, "EscapeSequence"], [Node, 2, "EscapeCode"], [Node, 2, "Identifier"], [_LiteralTagDecs, 2, "LiteralTag"], [_NumberDecs, 2, "Number"], [Node, 2, "UnsignedInteger"], [_IntegerDecs, 2, "Integer"], [_BooleanDecs, 2, "Boolean"], [_InfinityDecs, 2, "Infinity"], [_PunctuatorDecs, 2, "Punctuator"], [_KeywordDecs, 2, "Keyword"], [_AnyDecs, 2, "Any"]], []).e;
  }
  constructor() {
    _initProto(this);
  }
  *[(_DoctypeTagDecs = [CoveredBy('Tag'), CoveredBy('Expression'), Node], _ReferenceTagDecs = [Node, CoveredBy('Tag'), CoveredBy('Expression')], _GapTagDecs = [Node, CoveredBy('Tag'), CoveredBy('Expression'), CoveredBy('PropertyValue')], _ShiftTagDecs = [Node, CoveredBy('Tag')], _NullTagDecs = [Node, CoveredBy('Tag'), CoveredBy('Expression'), CoveredBy('PropertyValue')], _ArrayTagDecs = [Node, CoveredBy('Tag'), CoveredBy('PropertyValue')], _NodeDecs = [Node, CoveredBy('PropertyValue')], _PropertyDecs = [Node, CoveredBy('NodeChild'), CoveredBy('FragmentChild')], _OpenNodeTagDecs = [UnboundAttributes(['balanced', 'balancedSpan']), Node, CoveredBy('Tag'), CoveredBy('OpenTag')], _OpenFragmentTagDecs = [Attributes({
    balanced: true,
    balancedSpan: 'FragmentChildren'
  }), Node, CoveredBy('Tag'), CoveredBy('OpenTag')], _CloseNodeTagDecs = [Attributes({
    balancer: true
  }), Node, CoveredBy('Tag'), CoveredBy('CloseTag')], _CloseFragmentTagDecs = [Attributes({
    balancer: true
  }), Node, CoveredBy('Tag'), CoveredBy('CloseTag')], _BooleanAttributeDecs = [UnboundAttributes(['true']), Node, CoveredBy('Attribute')], _MappingAttributeDecs = [Node, CoveredBy('Attribute')], _IdentifierPathDecs = [CoveredBy('Language'), Node], _StringDecs = [CoveredBy('AttributeValue'), CoveredBy('Language'), Node], _LiteralTagDecs = [Node, CoveredBy('Tag'), CoveredBy('Expression'), CoveredBy('NodeChild'), CoveredBy('FragmentChild')], _NumberDecs = CoveredBy('AttributeValue'), _IntegerDecs = [CoveredBy('Number'), Node], _BooleanDecs = [CoveredBy('AttributeValue'), Node], _InfinityDecs = [CoveredBy('Number'), Node], _PunctuatorDecs = [Node, InjectFrom(productions)], _KeywordDecs = [Node, InjectFrom(productions)], _AnyDecs = InjectFrom(productions), Symbol.for('@bablr/fragment'))]() {
    yield* eatMatchTrivia();
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield* eatMatchTrivia();
  }
  *Stream() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "DoctypeTag"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("<!")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit(".[]")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    while (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [9, [[_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`], [_t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`]]], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Any"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit(".[]")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {}), _t.node(_l.Instruction, "Array", [23, [[_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.arr()], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {}))], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {}))], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {}))], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n    ")], {}, {})), _t.ref`closeToken`]]], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "["),
          elements: [9, [[_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "NullTag"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("null")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "ArrayTag"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("[]")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "ReferenceTag"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [9, [[_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`], [_t.ref`separators[]`, _t.arr(), _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`closeToken`]]], {
                openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\.")], {}, {
                    cooked: "."
                  }))], {}, {})]
                }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                      min: _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}),
                      rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                      max: _t.node(_l.Regex, "Character", [_t.lit("z")], {}, {})
                    }, {}), _t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                      min: _t.node(_l.Regex, "Character", [_t.lit("A")], {}, {}),
                      rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                      max: _t.node(_l.Regex, "Character", [_t.lit("Z")], {}, {})
                    }, {})],
                    closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  })]
                }, {})],
                separators: [_t.s_node(_l.Regex, "Punctuator", "|")],
                closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "LiteralTag"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "Character", [_t.lit("'")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("\"")], {}, {})],
                    closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  })]
                }, {})],
                closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})], [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "DoctypeTag"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("<!")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "GapTag"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("<//>")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "ShiftTag"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("^^^")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "CloseTag"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("</")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "OpenTag"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("<")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})]]],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", "]")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {}));
  }
  *Expression() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [9, [[_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`], [_t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`]]], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Any"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
          sigilToken: _t.s_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.Instruction, "Array", [17, [[_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.arr()], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {}))], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {}))], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n    ")], {}, {})), _t.ref`closeToken`]]], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "["),
          elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "NullTag"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("null")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "ReferenceTag"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [9, [[_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`], [_t.ref`separators[]`, _t.arr(), _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`closeToken`]]], {
                openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\.")], {}, {
                    cooked: "."
                  }))], {}, {})]
                }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                      min: _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}),
                      rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                      max: _t.node(_l.Regex, "Character", [_t.lit("z")], {}, {})
                    }, {}), _t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                      min: _t.node(_l.Regex, "Character", [_t.lit("A")], {}, {}),
                      rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                      max: _t.node(_l.Regex, "Character", [_t.lit("Z")], {}, {})
                    }, {})],
                    closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  })]
                }, {})],
                separators: [_t.s_node(_l.Regex, "Punctuator", "|")],
                closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "LiteralTag"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "Character", [_t.lit("'")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("\"")], {}, {})],
                    closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  })]
                }, {})],
                closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "DoctypeTag"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("<!")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "GapTag"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("<//>")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Node"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("<")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", "]")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Tag() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [9, [[_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`], [_t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`]]], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Any"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
          sigilToken: _t.s_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.Instruction, "Array", [23, [[_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.arr()], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {}))], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {}))], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {}))], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n    ")], {}, {})), _t.ref`closeToken`]]], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "["),
          elements: [9, [[_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "NullTag"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("null")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "ArrayTag"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("[]")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "ReferenceTag"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [9, [[_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`], [_t.ref`separators[]`, _t.arr(), _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`closeToken`]]], {
                openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\.")], {}, {
                    cooked: "."
                  }))], {}, {})]
                }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                      min: _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}),
                      rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                      max: _t.node(_l.Regex, "Character", [_t.lit("z")], {}, {})
                    }, {}), _t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                      min: _t.node(_l.Regex, "Character", [_t.lit("A")], {}, {}),
                      rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                      max: _t.node(_l.Regex, "Character", [_t.lit("Z")], {}, {})
                    }, {})],
                    closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  })]
                }, {})],
                separators: [_t.s_node(_l.Regex, "Punctuator", "|")],
                closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "LiteralTag"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "Character", [_t.lit("'")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("\"")], {}, {})],
                    closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  })]
                }, {})],
                closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})], [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "DoctypeTag"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("<!")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "GapTag"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("<//>")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "ShiftTag"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("^^^")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "OpenFragmentTag"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [9, [[_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`], [_t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`]]], {
                  elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\<")], {}, {
                    cooked: "<"
                  }))], {}, {}), _t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                    element: _t.node(_l.Regex, "Character", [_t.lit("#")], {}, {}),
                    value: _t.s_node(_l.Regex, "Keyword", "?")
                  }, {
                    min: 0,
                    max: 1,
                    greedy: true
                  }), _t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                    element: _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\*")], {}, {
                      cooked: "*"
                    }))], {}, {}),
                    value: _t.s_node(_l.Regex, "Keyword", "?")
                  }, {
                    min: 0,
                    max: 1,
                    greedy: true
                  }), _t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                    element: _t.node(_l.Regex, "Character", [_t.lit("@")], {}, {}),
                    value: _t.s_node(_l.Regex, "Keyword", "?")
                  }, {
                    min: 0,
                    max: 1,
                    greedy: true
                  }), _t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                    element: _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\+")], {}, {
                      cooked: "+"
                    }))], {}, {}),
                    value: _t.s_node(_l.Regex, "Keyword", "?")
                  }, {
                    min: 0,
                    max: 1,
                    greedy: true
                  }), _t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                    element: _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\$")], {}, {
                      cooked: "$"
                    }))], {}, {}),
                    value: _t.s_node(_l.Regex, "Keyword", "?")
                  }, {
                    min: 0,
                    max: 1,
                    greedy: true
                  }), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\>")], {}, {
                    cooked: ">"
                  }))], {}, {})]
                }, {})],
                closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "OpenNodeTag"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("<")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})]]],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", "]")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Document() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "DoctypeTag"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("doctype$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield* eatMatchTrivia();
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Fragment"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("tree$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *DoctypeTag() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [14, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr()], [_t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("<!")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancedSpan"),
              mapToken: _t.s_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("Tag")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {}), _t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
              mapToken: _t.s_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit(">")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "UnsignedInteger"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("version$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit(":")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("versionSeparatorToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("cstml")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("doctypeToken$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield* eatMatchTrivia();
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Attributes"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("attributes[]$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [12, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit(">")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancer")
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *ReferenceTag() {
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit(".")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
                tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit(".")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("name$")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
                tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Identifier"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("name$")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
    yield* eatMatchTrivia();
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("[]")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("arrayOperatorToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield* eatMatchTrivia();
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("$")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("hasGapToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield* eatMatchTrivia();
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit(":")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("sigilToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *GapTag() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("<//>")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("sigilToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *ShiftTag() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("^^^")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("sigilToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *NullTag() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("null")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("sigilToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *ArrayTag() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("[]")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("sigilToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Node() {
    let open = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "OpenNodeTag"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("open")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield* eatMatchTrivia();

    // Problem: not handling gaps
    //   gaps have a non-nullish representation
    //

    const flags = open.get('flags');
    const selfClosingTagToken = open.get('selfClosingTagToken');
    const token = notNull(flags.get('tokenToken'));
    const selfClosing = notNull(selfClosingTagToken);
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Instruction, "Array", [_t.ref`openToken`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "["),
          closeToken: _t.s_node(_l.Instruction, "Punctuator", "]")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("children[]$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    if (selfClosing) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
            sigilToken: _t.s_node(_l.Instruction, "Keyword", "null")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("close")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else {
      while ((yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "match"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
            alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
              elements: [_t.node(_l.Regex, "AnyCharacterSet", [_t.ref`sigilToken`], {
                sigilToken: _t.s_node(_l.Regex, "Keyword", ".")
              }, {})]
            }, {})],
            closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {})) && !(yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "match"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("</")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {}))) {
        yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
          verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
          arguments: _t.node(_l.Instruction, "Tuple", [9, [[_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`], [_t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
            values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
              open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
                flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
                type: _t.s_node(_l.Spamex, "Identifier", "NodeChild"),
                selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
                closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
              }, {})
            }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("children[]$")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}), _t.node(_l.Instruction, "Object", [_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`properties[]`, _t.arr(), _t.ref`properties[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Instruction, "Punctuator", "{"),
              properties: [_t.node(_l.Instruction, "Property", [_t.ref`key`, _t.ref`mapToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`value`], {
                key: _t.node(_l.Instruction, "Literal", [_t.lit("token")], {}, {}),
                mapToken: _t.s_node(_l.Instruction, "Punctuator", ":"),
                value: buildBoolean(token)
              }, {})],
              closeToken: _t.s_node(_l.Instruction, "Punctuator", "}")
            }, {})],
            closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
          }, {})
        }, {});
        yield* eatMatchTrivia();
      }
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "CloseNodeTag"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("close")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *Fragment() {
    let open = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "OpenFragmentTag"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("open")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield* eatMatchTrivia();
    const flags = open.get('flags');
    const token = notNull(flags.get('tokenToken'));
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Instruction, "Array", [_t.ref`openToken`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "["),
          closeToken: _t.s_node(_l.Instruction, "Punctuator", "]")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("children[]$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    while ((yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "AnyCharacterSet", [_t.ref`sigilToken`], {
              sigilToken: _t.s_node(_l.Regex, "Keyword", ".")
            }, {})]
          }, {})],
          closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) && !(yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("</")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {}))) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [9, [[_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`], [_t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`]]], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "FragmentChild"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("children[]$")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {}), _t.node(_l.Instruction, "Object", [_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`properties[]`, _t.arr(), _t.ref`properties[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Instruction, "Punctuator", "{"),
            properties: [_t.node(_l.Instruction, "Property", [_t.ref`key`, _t.ref`mapToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`value`], {
              key: _t.node(_l.Instruction, "Literal", [_t.lit("token")], {}, {}),
              mapToken: _t.s_node(_l.Instruction, "Punctuator", ":"),
              value: buildBoolean(token)
            }, {})],
            closeToken: _t.s_node(_l.Instruction, "Punctuator", "}")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      yield* eatMatchTrivia();
    }
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "CloseFragmentTag"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("close")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *NodeChild({
    value: props,
    ctx
  }) {
    const {
      token
    } = ctx.unbox(props || {});
    if (token && ctx.unbox(token)) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [9, [[_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`], [_t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`]]], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Any"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
            sigilToken: _t.s_node(_l.Instruction, "Keyword", "null")
          }, {}), _t.node(_l.Instruction, "Array", [9, [[_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.arr()], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Instruction, "Punctuator", "["),
            elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
              open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
                flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
                type: _t.s_node(_l.Spamex, "Identifier", "Node"),
                intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                  openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                  alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`], {
                    elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\<")], {}, {
                      cooked: "<"
                    }))], {}, {}), _t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                      element: _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\*")], {}, {
                        cooked: "*"
                      }))], {}, {}),
                      value: _t.s_node(_l.Regex, "Keyword", "?")
                    }, {
                      min: 0,
                      max: 1,
                      greedy: true
                    }), _t.node(_l.Regex, "Character", [_t.lit("@")], {}, {})]
                  }, {})],
                  closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
                }, {}),
                selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
                closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
              }, {})
            }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
              open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
                flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
                type: _t.s_node(_l.Spamex, "Identifier", "LiteralTag"),
                intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                  openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                  alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                    elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                      openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                      elements: [_t.node(_l.Regex, "Character", [_t.lit("'")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("\"")], {}, {})],
                      closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                    }, {
                      negate: false
                    })]
                  }, {})],
                  closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
                }, {}),
                selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
                closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
              }, {})
            }, {})],
            closeToken: _t.s_node(_l.Instruction, "Punctuator", "]")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [9, [[_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`], [_t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`]]], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Any"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
            sigilToken: _t.s_node(_l.Instruction, "Keyword", "null")
          }, {}), _t.node(_l.Instruction, "Array", [11, [[_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n          ")], {}, {})), _t.ref`elements[]`, _t.arr()], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n          ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n          ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Instruction, "Punctuator", "["),
            elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
              open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
                flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
                type: _t.s_node(_l.Spamex, "Identifier", "Node"),
                intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                  openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                  alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`], {
                    elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\<")], {}, {
                      cooked: "<"
                    }))], {}, {}), _t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                      element: _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\*")], {}, {
                        cooked: "*"
                      }))], {}, {}),
                      value: _t.s_node(_l.Regex, "Keyword", "?")
                    }, {
                      min: 0,
                      max: 1,
                      greedy: true
                    }), _t.node(_l.Regex, "Character", [_t.lit("#")], {}, {})]
                  }, {})],
                  closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
                }, {}),
                selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
                closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
              }, {})
            }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
              open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
                flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
                type: _t.s_node(_l.Spamex, "Identifier", "Property"),
                intrinsicValue: _t.node(_l.Regex, "Pattern", [9, [[_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`], [_t.ref`separators[]`, _t.arr(), _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`closeToken`]]], {
                  openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                  alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                    elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\.")], {}, {
                      cooked: "."
                    }))], {}, {})]
                  }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                    elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                      openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                      elements: [_t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                        min: _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}),
                        rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                        max: _t.node(_l.Regex, "Character", [_t.lit("z")], {}, {})
                      }, {}), _t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                        min: _t.node(_l.Regex, "Character", [_t.lit("A")], {}, {}),
                        rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                        max: _t.node(_l.Regex, "Character", [_t.lit("Z")], {}, {})
                      }, {})],
                      closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                    }, {
                      negate: false
                    })]
                  }, {})],
                  separators: [_t.s_node(_l.Regex, "Punctuator", "|")],
                  closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
                }, {}),
                selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
                closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
              }, {})
            }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
              open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
                flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
                type: _t.s_node(_l.Spamex, "Identifier", "ShiftTag"),
                intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                  openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                  content: _t.node(_l.CSTML, "Content", [_t.lit("^^^")], {}, {}),
                  closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
                }, {}),
                selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
                closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
              }, {})
            }, {})],
            closeToken: _t.s_node(_l.Instruction, "Punctuator", "]")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *FragmentChild({
    value: props,
    ctx
  }) {
    const {
      token
    } = ctx.unbox(props || {});
    if (token && ctx.unbox(token)) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [9, [[_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`], [_t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`]]], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Any"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
            sigilToken: _t.s_node(_l.Instruction, "Keyword", "null")
          }, {}), _t.node(_l.Instruction, "Array", [9, [[_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.arr()], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Instruction, "Punctuator", "["),
            elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
              open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
                flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
                type: _t.s_node(_l.Spamex, "Identifier", "Node"),
                intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                  openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                  alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`], {
                    elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\<")], {}, {
                      cooked: "<"
                    }))], {}, {}), _t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                      element: _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\*")], {}, {
                        cooked: "*"
                      }))], {}, {}),
                      value: _t.s_node(_l.Regex, "Keyword", "?")
                    }, {
                      min: 0,
                      max: 1,
                      greedy: true
                    }), _t.node(_l.Regex, "Character", [_t.lit("@")], {}, {})]
                  }, {})],
                  closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
                }, {}),
                selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
                closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
              }, {})
            }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
              open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
                flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
                type: _t.s_node(_l.Spamex, "Identifier", "LiteralTag"),
                intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                  openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                  alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                    elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                      openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                      elements: [_t.node(_l.Regex, "Character", [_t.lit("'")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("\"")], {}, {})],
                      closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                    }, {
                      negate: false
                    })]
                  }, {})],
                  closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
                }, {}),
                selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
                closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
              }, {})
            }, {})],
            closeToken: _t.s_node(_l.Instruction, "Punctuator", "]")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [9, [[_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`], [_t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`]]], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Any"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
            sigilToken: _t.s_node(_l.Instruction, "Keyword", "null")
          }, {}), _t.node(_l.Instruction, "Array", [9, [[_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n          ")], {}, {})), _t.ref`elements[]`, _t.arr()], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n          ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Instruction, "Punctuator", "["),
            elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
              open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
                flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
                type: _t.s_node(_l.Spamex, "Identifier", "Node"),
                intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                  openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                  alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`], {
                    elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\<")], {}, {
                      cooked: "<"
                    }))], {}, {}), _t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                      element: _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\*")], {}, {
                        cooked: "*"
                      }))], {}, {}),
                      value: _t.s_node(_l.Regex, "Keyword", "?")
                    }, {
                      min: 0,
                      max: 1,
                      greedy: true
                    }), _t.node(_l.Regex, "Character", [_t.lit("#")], {}, {})]
                  }, {})],
                  closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
                }, {}),
                selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
                closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
              }, {})
            }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
              open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
                flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
                type: _t.s_node(_l.Spamex, "Identifier", "Property"),
                intrinsicValue: _t.node(_l.Regex, "Pattern", [9, [[_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`], [_t.ref`separators[]`, _t.arr(), _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`closeToken`]]], {
                  openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                  alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                    elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\.")], {}, {
                      cooked: "."
                    }))], {}, {})]
                  }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                    elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                      openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                      elements: [_t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                        min: _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}),
                        rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                        max: _t.node(_l.Regex, "Character", [_t.lit("z")], {}, {})
                      }, {}), _t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                        min: _t.node(_l.Regex, "Character", [_t.lit("A")], {}, {}),
                        rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                        max: _t.node(_l.Regex, "Character", [_t.lit("Z")], {}, {})
                      }, {})],
                      closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                    }, {
                      negate: false
                    })]
                  }, {})],
                  separators: [_t.s_node(_l.Regex, "Punctuator", "|")],
                  closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
                }, {}),
                selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
                closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
              }, {})
            }, {})],
            closeToken: _t.s_node(_l.Instruction, "Punctuator", "]")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *Property() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "ReferenceTag"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("reference$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield* eatMatchTrivia();
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "PropertyValue"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("node$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *PropertyValue() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [9, [[_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`], [_t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`]]], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Any"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
          sigilToken: _t.s_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.Instruction, "Array", [13, [[_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.arr()], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {}))], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n    ")], {}, {})), _t.ref`closeToken`]]], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "["),
          elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "NullTag"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("null")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "GapTag"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("<//>")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "ArrayTag"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("[]")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Node"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\<")], {}, {
                    cooked: "<"
                  }))], {}, {}), _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`negateToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                    negateToken: _t.s_node(_l.Regex, "Keyword", "^"),
                    elements: [_t.node(_l.Regex, "Character", [_t.lit("#")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("@")], {}, {})],
                    closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: true
                  })]
                }, {})],
                closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", "]")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Flags() {
    let tr = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("#")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("triviaToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("*")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("tokenToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let esc = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("@")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("escapeToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let exp = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("+")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("expressionToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("$")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("hasGapToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    if (tr && esc || exp && (tr || esc)) yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "fail"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *OpenTag({
    s
  }) {
    if (s.span === 'NodeChildren' || s.span === 'FragmentChildren') {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "OpenNodeTag"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else if (s.span === 'Bare' || s.span === 'Stream') {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "OpenFragmentTag"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "fail"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *OpenNodeTag({
    s
  }) {
    const outerSpan = s.span;
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [14, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr()], [_t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("<")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancedSpan"),
              mapToken: _t.s_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("Tag")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {}), _t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
              mapToken: _t.s_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit(">")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let flags = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Flags"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("flags")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "TagType"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let sp = yield* eatMatchTrivia();
    if (sp && flags.get('tokenToken') && (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Regex, "Punctuator", "["),
              elements: [_t.node(_l.Regex, "Character", [_t.lit("'")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("\"")], {}, {})],
              closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
            }, {
              negate: false
            })]
          }, {})],
          closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {}))) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "String"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("intrinsicValue$")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      sp = yield* eatMatchTrivia();
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
            sigilToken: _t.s_node(_l.Instruction, "Keyword", "null")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("intrinsicValue$")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Attributes"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("attributes[]$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let sc = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("/")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("selfClosingTagToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    const balanced = !sc && (s.path.depth > 1 || outerSpan !== 'Bare');
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), ..._interpolateFragmentChildren(buildBoolean(balanced), _t.ref`values[]`), _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("balanced")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {}), ..._interpolateArray(buildBoolean(balanced))],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), ..._interpolateFragmentChildren(balanced ? buildString('NodeChildren') : buildNullTag(), _t.ref`values[]`), _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("balancedSpan")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {}), ..._interpolateArray(balanced ? buildString('NodeChildren') : buildNullTag())],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [12, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit(">")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancer")
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *OpenFragmentTag() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [14, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr()], [_t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("<")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancedSpan"),
              mapToken: _t.s_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("Tag")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {}), _t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
              mapToken: _t.s_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit(">")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Flags"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("flags")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [12, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit(">")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancer")
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Attributes() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Instruction, "Array", [_t.ref`openToken`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "["),
          closeToken: _t.s_node(_l.Instruction, "Punctuator", "]")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit(".[]$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let sp = true;
    while (sp && (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [9, [[_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`], [_t.ref`separators[]`, _t.arr(), _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`closeToken`]]], {
          openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
              element: _t.node(_l.Regex, "Character", [_t.lit("!")], {}, {}),
              value: _t.s_node(_l.Regex, "Keyword", "?")
            }, {
              min: 0,
              max: 1,
              greedy: true
            }), _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Regex, "Punctuator", "["),
              elements: [_t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                min: _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}),
                rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                max: _t.node(_l.Regex, "Character", [_t.lit("z")], {}, {})
              }, {}), _t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                min: _t.node(_l.Regex, "Character", [_t.lit("A")], {}, {}),
                rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                max: _t.node(_l.Regex, "Character", [_t.lit("Z")], {}, {})
              }, {})],
              closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
            }, {
              negate: false
            })]
          }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "Gap", [_t.ref`escapeToken`, _t.ref`value`], {
              escapeToken: _t.s_node(_l.Regex, "Punctuator", "\\"),
              value: _t.s_node(_l.Regex, "Keyword", "g")
            }, {})]
          }, {})],
          separators: [_t.s_node(_l.Regex, "Punctuator", "|")],
          closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {}))) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Attribute"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit(".[]$")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      sp = yield* eatMatchTrivia();
    }
  }
  *CloseTag({
    s
  }) {
    if (s.span === 'NodeChildren') {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "CloseNodeTag"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else if (s.span === 'FragmentChildren') {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "CloseFragmentTag"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "fail"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *CloseNodeTag() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [12, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("</")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
              mapToken: _t.s_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit(">")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "TagType"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [12, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit(">")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancer")
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *CloseFragmentTag() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [12, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("</")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
              mapToken: _t.s_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit(">")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [12, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit(">")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancer")
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Attribute() {
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "CapturingGroup", [9, [[_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`], [_t.ref`separators[]`, _t.arr(), _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`closeToken`]]], {
              openToken: _t.s_node(_l.Regex, "Punctuator", "("),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                  openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                  elements: [_t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                    min: _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}),
                    rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                    max: _t.node(_l.Regex, "Character", [_t.lit("z")], {}, {})
                  }, {}), _t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                    min: _t.node(_l.Regex, "Character", [_t.lit("A")], {}, {}),
                    rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                    max: _t.node(_l.Regex, "Character", [_t.lit("Z")], {}, {})
                  }, {})],
                  closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                }, {
                  negate: false
                }), _t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                  element: _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                      min: _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}),
                      rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                      max: _t.node(_l.Regex, "Character", [_t.lit("z")], {}, {})
                    }, {}), _t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                      min: _t.node(_l.Regex, "Character", [_t.lit("A")], {}, {}),
                      rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                      max: _t.node(_l.Regex, "Character", [_t.lit("Z")], {}, {})
                    }, {}), _t.node(_l.Regex, "Character", [_t.lit("_")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("-")], {}, {})],
                    closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  }),
                  value: _t.s_node(_l.Regex, "Keyword", "*")
                }, {
                  min: 0,
                  max: Infinity,
                  greedy: true
                })]
              }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Gap", [_t.ref`escapeToken`, _t.ref`value`], {
                  escapeToken: _t.s_node(_l.Regex, "Punctuator", "\\"),
                  value: _t.s_node(_l.Regex, "Keyword", "g")
                }, {})]
              }, {})],
              separators: [_t.s_node(_l.Regex, "Punctuator", "|")],
              closeToken: _t.s_node(_l.Regex, "Punctuator", ")")
            }, {}), _t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
              element: _t.node(_l.Regex, "SpaceCharacterSet", [_t.ref`escapeToken`, _t.ref`value`], {
                escapeToken: _t.s_node(_l.Regex, "Punctuator", "\\"),
                value: _t.s_node(_l.Regex, "Keyword", "s")
              }, {}),
              value: _t.s_node(_l.Regex, "Keyword", "*")
            }, {
              min: 0,
              max: Infinity,
              greedy: true
            }), _t.node(_l.Regex, "Character", [_t.lit("=")], {}, {})]
          }, {})],
          closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "MappingAttribute"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "BooleanAttribute"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *BooleanAttribute() {
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("!")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("negateToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("true")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {}), _t.node(_l.Instruction, "Boolean", [_t.ref`sigilToken`], {
            sigilToken: _t.s_node(_l.Instruction, "Keyword", "false")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("true")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {}), _t.node(_l.Instruction, "Boolean", [_t.ref`sigilToken`], {
            sigilToken: _t.s_node(_l.Instruction, "Keyword", "true")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Identifier"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("key$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *MappingAttribute() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Identifier"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("key$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield* eatMatchTrivia();
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("=")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("sigilToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield* eatMatchTrivia();
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "AttributeValue"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *AttributeValue() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [9, [[_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`], [_t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`]]], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Any"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
          sigilToken: _t.s_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.Instruction, "Array", [11, [[_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.arr()], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`closeToken`]]], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "["),
          elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "String"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "Character", [_t.lit("'")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("\"")], {}, {})],
                    closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  })]
                }, {})],
                closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Number"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "DigitCharacterSet", [_t.ref`escapeToken`, _t.ref`value`], {
                      escapeToken: _t.s_node(_l.Regex, "Punctuator", "\\"),
                      value: _t.s_node(_l.Regex, "Keyword", "d")
                    }, {}), _t.node(_l.Regex, "Character", [_t.lit("+")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("-")], {}, {})],
                    closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  })]
                }, {})],
                closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Boolean"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [9, [[_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`], [_t.ref`separators[]`, _t.arr(), _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`closeToken`]]], {
                openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Character", [_t.lit("t")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("r")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("u")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("e")], {}, {})]
                }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Character", [_t.lit("f")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("l")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("s")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("e")], {}, {})]
                }, {})],
                separators: [_t.s_node(_l.Regex, "Punctuator", "|")],
                closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", "]")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *TagType() {
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [9, [[_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`], [_t.ref`separators[]`, _t.arr(), _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`closeToken`]]], {
          openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Regex, "Punctuator", "["),
              elements: [_t.node(_l.Regex, "Character", [_t.lit("'")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("\"")], {}, {})],
              closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
            }, {
              negate: false
            })]
          }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "CapturingGroup", [9, [[_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`], [_t.ref`separators[]`, _t.arr(), _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`closeToken`]]], {
              openToken: _t.s_node(_l.Regex, "Punctuator", "("),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                  element: _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                      min: _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}),
                      rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                      max: _t.node(_l.Regex, "Character", [_t.lit("z")], {}, {})
                    }, {}), _t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                      min: _t.node(_l.Regex, "Character", [_t.lit("A")], {}, {}),
                      rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                      max: _t.node(_l.Regex, "Character", [_t.lit("Z")], {}, {})
                    }, {}), _t.node(_l.Regex, "Character", [_t.lit(".")], {}, {})],
                    closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  }),
                  value: _t.s_node(_l.Regex, "Keyword", "+")
                }, {
                  min: 1,
                  max: Infinity,
                  greedy: true
                })]
              }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Gap", [_t.ref`escapeToken`, _t.ref`value`], {
                  escapeToken: _t.s_node(_l.Regex, "Punctuator", "\\"),
                  value: _t.s_node(_l.Regex, "Keyword", "g")
                }, {})]
              }, {})],
              separators: [_t.s_node(_l.Regex, "Punctuator", "|")],
              closeToken: _t.s_node(_l.Regex, "Punctuator", ")")
            }, {}), _t.node(_l.Regex, "Character", [_t.lit(":")], {}, {})]
          }, {})],
          separators: [_t.s_node(_l.Regex, "Punctuator", "|")],
          closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Language"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("language$")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
                tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit(":")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("namespaceSeparatorToken")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
                tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Identifier"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("type$")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Regex, "Punctuator", "["),
              elements: [_t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                min: _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}),
                rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                max: _t.node(_l.Regex, "Character", [_t.lit("z")], {}, {})
              }, {}), _t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                min: _t.node(_l.Regex, "Character", [_t.lit("A")], {}, {}),
                rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                max: _t.node(_l.Regex, "Character", [_t.lit("Z")], {}, {})
              }, {})],
              closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
            }, {
              negate: false
            })]
          }, {})],
          closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
            sigilToken: _t.s_node(_l.Instruction, "Keyword", "null")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("language$")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
                tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Identifier"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("type$")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
            sigilToken: _t.s_node(_l.Instruction, "Keyword", "null")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("language$")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
            sigilToken: _t.s_node(_l.Instruction, "Keyword", "null")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("type$")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *Language() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [9, [[_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`], [_t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`]]], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Any"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
          sigilToken: _t.s_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.Instruction, "Array", [9, [[_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.arr()], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n    ")], {}, {})), _t.ref`closeToken`]]], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "["),
          elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "String"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "Character", [_t.lit("'")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("\"")], {}, {})],
                    closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  })]
                }, {})],
                closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "IdentifierPath"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                      min: _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}),
                      rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                      max: _t.node(_l.Regex, "Character", [_t.lit("z")], {}, {})
                    }, {}), _t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                      min: _t.node(_l.Regex, "Character", [_t.lit("A")], {}, {}),
                      rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                      max: _t.node(_l.Regex, "Character", [_t.lit("Z")], {}, {})
                    }, {})],
                    closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  })]
                }, {})],
                closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", "]")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *IdentifierPath() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Identifier"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("segments[]$")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    while (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit(".")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
                tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit(".")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("separators[]")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
                tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Identifier"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("segments[]$")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *String({
    ctx
  }) {
    let q = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Regex, "Punctuator", "["),
              elements: [_t.node(_l.Regex, "Character", [_t.lit("'")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("\"")], {}, {})],
              closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
            }, {
              negate: false
            })]
          }, {})],
          closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    if (!q) yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "fail"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    const q_ = ctx.sourceTextFor(q);
    yield q_ === "'" ? _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [14, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr()], [_t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "\""),
              content: _t.node(_l.CSTML, "Content", [_t.lit("'")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "\"")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
              mapToken: _t.s_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "\""),
                content: _t.node(_l.CSTML, "Content", [_t.lit("'")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "\"")
              }, {})
            }, {}), _t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancedSpan"),
              mapToken: _t.s_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("String:Single")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {}) : _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [14, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr()], [_t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("\"")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
              mapToken: _t.s_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("\"")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {}), _t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancedSpan"),
              mapToken: _t.s_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("String:Double")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "StringContent"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("content")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield q_ === "'" ? _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [12, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "\""),
              content: _t.node(_l.CSTML, "Content", [_t.lit("'")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "\"")
            }, {}),
            attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancer")
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {}) : _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [12, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("\"")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancer")
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *StringContent({
    state: {
      span
    }
  }) {
    let esc, lit;
    do {
      esc = (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "match"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
              cooked: "\\"
            }))], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {})) && (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`escapeToken`], {
                escapeToken: _t.s_node(_l.CSTML, "Punctuator", "@")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "EscapeSequence"),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {}));
      lit = span === 'String:Single' ? yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
            alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
              elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                element: _t.node(_l.Regex, "CharacterClass", [10, [[_t.ref`openToken`, _t.ref`negateToken`, _t.ref`elements[]`, _t.arr()], [_t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`]]], {
                  openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                  negateToken: _t.s_node(_l.Regex, "Keyword", "^"),
                  elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\r")], {}, {
                    cooked: "\r"
                  }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\n")], {}, {
                    cooked: "\n"
                  }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\\\")], {}, {
                    cooked: "\\"
                  }))], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("'")], {}, {}), _t.node(_l.Regex, "Gap", [_t.ref`escapeToken`, _t.ref`value`], {
                    escapeToken: _t.s_node(_l.Regex, "Punctuator", "\\"),
                    value: _t.s_node(_l.Regex, "Keyword", "g")
                  }, {})],
                  closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                }, {
                  negate: true
                }),
                value: _t.s_node(_l.Regex, "Keyword", "+")
              }, {
                min: 1,
                max: Infinity,
                greedy: true
              })]
            }, {})],
            closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {}) : yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
            alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
              elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                element: _t.node(_l.Regex, "CharacterClass", [10, [[_t.ref`openToken`, _t.ref`negateToken`, _t.ref`elements[]`, _t.arr()], [_t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`]]], {
                  openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                  negateToken: _t.s_node(_l.Regex, "Keyword", "^"),
                  elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\r")], {}, {
                    cooked: "\r"
                  }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\n")], {}, {
                    cooked: "\n"
                  }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\\\")], {}, {
                    cooked: "\\"
                  }))], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("\"")], {}, {}), _t.node(_l.Regex, "Gap", [_t.ref`escapeToken`, _t.ref`value`], {
                    escapeToken: _t.s_node(_l.Regex, "Punctuator", "\\"),
                    value: _t.s_node(_l.Regex, "Keyword", "g")
                  }, {})],
                  closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                }, {
                  negate: true
                }),
                value: _t.s_node(_l.Regex, "Keyword", "+")
              }, {
                min: 1,
                max: Infinity,
                greedy: true
              })]
            }, {})],
            closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } while (esc || lit);
  }
  *EscapeSequence({
    state: {
      span
    },
    ctx
  }) {
    if (!span.startsWith('String')) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "fail"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [12, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
                cooked: "\\"
              }))], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "openSpan"),
              mapToken: _t.s_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("Escape")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("escapeToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let match;
    if (match = span === 'String:Single' ? yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "CharacterClass", [11, [[_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], [_t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`]]], {
              openToken: _t.s_node(_l.Regex, "Punctuator", "["),
              elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\\\")], {}, {
                cooked: "\\"
              }))], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("/")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("n")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("r")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("t")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("0")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("'")], {}, {})],
              closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
            }, {
              negate: false
            })]
          }, {})],
          closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {}) : yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "CharacterClass", [11, [[_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], [_t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`]]], {
              openToken: _t.s_node(_l.Regex, "Punctuator", "["),
              elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\\\")], {}, {
                cooked: "\\"
              }))], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("/")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("n")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("r")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("t")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("0")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("\"")], {}, {})],
              closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
            }, {
              negate: false
            })]
          }, {})],
          closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      const match_ = ctx.sourceTextFor(match);
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [12, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
                tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
              intrinsicValue: buildString(match_),
              attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
                key: _t.s_node(_l.Spamex, "Identifier", "closeSpan"),
                mapToken: _t.s_node(_l.Spamex, "Punctuator", "="),
                value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                  openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                  content: _t.node(_l.CSTML, "Content", [_t.lit("Escape")], {}, {}),
                  closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
                }, {})
              }, {})],
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("code")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("u")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [10, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "EscapeCode"),
              attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
                key: _t.s_node(_l.Spamex, "Identifier", "closeSpan"),
                mapToken: _t.s_node(_l.Spamex, "Punctuator", "="),
                value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                  openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                  content: _t.node(_l.CSTML, "Content", [_t.lit("Escape")], {}, {}),
                  closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
                }, {})
              }, {})],
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("code")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "fail"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *EscapeCode() {
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("u")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("typeToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [12, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
                tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("{")], {}, {}),
                closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
                key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
                mapToken: _t.s_node(_l.Spamex, "Punctuator", "="),
                value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                  openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                  content: _t.node(_l.CSTML, "Content", [_t.lit("}")], {}, {}),
                  closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
                }, {})
              }, {})],
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
            closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {})) {
        yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
          verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
          arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
            values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
              open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
                flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
                  tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
                }, {}),
                type: _t.s_node(_l.Spamex, "Identifier", "UnsignedInteger"),
                selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
                closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
              }, {})
            }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("value$")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {})],
            closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
          }, {})
        }, {});
        yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
          verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
          arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
            values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
              open: _t.node(_l.Spamex, "OpenNodeMatcher", [12, [[_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {}))], [_t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`]]], {
                openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
                flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
                  tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
                }, {}),
                type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
                intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                  openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
                  content: _t.node(_l.CSTML, "Content", [_t.lit("}")], {}, {}),
                  closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
                }, {}),
                attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
                  key: _t.s_node(_l.Spamex, "Identifier", "balancer")
                }, {})],
                selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
                closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
              }, {})
            }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {})],
            closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
          }, {})
        }, {});
      } else {
        yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
          verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
          arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
            values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
              open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
                flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
                  tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
                }, {}),
                type: _t.s_node(_l.Spamex, "Identifier", "UnsignedInteger"),
                intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                  openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                  alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                    elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`openToken`, _t.ref`min`, _t.ref`closeToken`], {
                      element: _t.node(_l.Regex, "DigitCharacterSet", [_t.ref`escapeToken`, _t.ref`value`], {
                        escapeToken: _t.s_node(_l.Regex, "Punctuator", "\\"),
                        value: _t.s_node(_l.Regex, "Keyword", "d")
                      }, {}),
                      openToken: _t.s_node(_l.Regex, "Punctuator", "{"),
                      min: _t.node(_l.Regex, "Number", [_t.lit("4")], {}, {}),
                      closeToken: _t.s_node(_l.Regex, "Punctuator", "}")
                    }, {
                      min: 4,
                      max: undefined,
                      greedy: true
                    })]
                  }, {})],
                  closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
                }, {}),
                selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
                closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
              }, {})
            }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("value$")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {})],
            closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
          }, {})
        }, {});
        yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
          verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
          arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
            values: [_t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
              sigilToken: _t.s_node(_l.Instruction, "Keyword", "null")
            }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {})],
            closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
          }, {})
        }, {});
      }
    }
  }
  *Identifier() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Regex, "Punctuator", "["),
              elements: [_t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                min: _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}),
                rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                max: _t.node(_l.Regex, "Character", [_t.lit("z")], {}, {})
              }, {}), _t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                min: _t.node(_l.Regex, "Character", [_t.lit("A")], {}, {}),
                rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                max: _t.node(_l.Regex, "Character", [_t.lit("Z")], {}, {})
              }, {})],
              closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
            }, {
              negate: false
            }), _t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
              element: _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                elements: [_t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                  min: _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}),
                  rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                  max: _t.node(_l.Regex, "Character", [_t.lit("z")], {}, {})
                }, {}), _t.node(_l.Regex, "CharacterClassRange", [_t.ref`min`, _t.ref`rangeToken`, _t.ref`max`], {
                  min: _t.node(_l.Regex, "Character", [_t.lit("A")], {}, {}),
                  rangeToken: _t.s_node(_l.Regex, "Punctuator", "-"),
                  max: _t.node(_l.Regex, "Character", [_t.lit("Z")], {}, {})
                }, {}), _t.node(_l.Regex, "Character", [_t.lit("_")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("-")], {}, {})],
                closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
              }, {
                negate: false
              }),
              value: _t.s_node(_l.Regex, "Keyword", "*")
            }, {
              min: 0,
              max: Infinity,
              greedy: true
            })]
          }, {})],
          closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *LiteralTag() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "String"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Number() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [9, [[_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`], [_t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`]]], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Any"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
          sigilToken: _t.s_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.Instruction, "Array", [9, [[_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.arr()], [_t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n    ")], {}, {})), _t.ref`closeToken`]]], {
          openToken: _t.s_node(_l.Instruction, "Punctuator", "["),
          elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Integer"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
                    element: _t.node(_l.Regex, "Character", [_t.lit("-")], {}, {}),
                    value: _t.s_node(_l.Regex, "Keyword", "?")
                  }, {
                    min: 0,
                    max: 1,
                    greedy: true
                  }), _t.node(_l.Regex, "DigitCharacterSet", [_t.ref`escapeToken`, _t.ref`value`], {
                    escapeToken: _t.s_node(_l.Regex, "Punctuator", "\\"),
                    value: _t.s_node(_l.Regex, "Keyword", "d")
                  }, {})]
                }, {})],
                closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Infinity"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "Character", [_t.lit("+")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("-")], {}, {})],
                    closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  }), _t.node(_l.Regex, "Character", [_t.lit("I")], {}, {})]
                }, {})],
                closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_node(_l.Instruction, "Punctuator", "]")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *UnsignedInteger() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
              element: _t.node(_l.Regex, "DigitCharacterSet", [_t.ref`escapeToken`, _t.ref`value`], {
                escapeToken: _t.s_node(_l.Regex, "Punctuator", "\\"),
                value: _t.s_node(_l.Regex, "Keyword", "d")
              }, {}),
              value: _t.s_node(_l.Regex, "Keyword", "+")
            }, {
              min: 1,
              max: Infinity,
              greedy: true
            })]
          }, {})],
          closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Integer() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("-")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("signToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "UnsignedInteger"),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Boolean() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [9, [[_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`], [_t.ref`separators[]`, _t.arr(), _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`closeToken`]]], {
              openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Character", [_t.lit("t")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("r")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("u")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("e")], {}, {})]
              }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Character", [_t.lit("f")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("a")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("l")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("s")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("e")], {}, {})]
              }, {})],
              separators: [_t.s_node(_l.Regex, "Punctuator", "|")],
              closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("sigilToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Infinity() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                  openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                  elements: [_t.node(_l.Regex, "Character", [_t.lit("+")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("-")], {}, {})],
                  closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
                }, {
                  negate: false
                })]
              }, {})],
              closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("signToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("Infinity")], {}, {}),
              closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("sigilToken")], {}, {}),
          closeToken: _t.s_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Punctuator() {}
  *Keyword() {}
  *Any() {}
};